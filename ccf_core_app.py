# -*- coding: utf-8 -*-
"""ccf_core_app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xVrtMckHz-EGs8gGnWCgo_F4iiKEPY-t
"""

# ccf_core.py
# Funções reutilizáveis para gerar master wide e classificar CCF.
# Não faz upload/IO por conta própria — retorna/recebe DataFrames.

import re
import unicodedata
from collections import defaultdict
import pandas as pd

# -----------------------------
# Utilitários
# -----------------------------
def normalize_text(s: str) -> str:
    if s is None:
        return ""
    s = str(s)
    s = unicodedata.normalize("NFKD", s)
    s = "".join(c for c in s if not unicodedata.combining(c))
    return s.lower()

def build_version_id(version_val, pack_val, fmt="{version} + {pack}"):
    v = "" if pd.isna(version_val) else str(version_val).strip()
    p = "" if pd.isna(pack_val) else str(pack_val).strip()
    if p == "" or p.lower() in ["nan", "none"]:
        return v
    return fmt.format(version=v, pack=p)

# -----------------------------
# Conversão LONG -> WIDE (Version x Attr)
# -----------------------------
def long_to_wide_with_pack(df_long: pd.DataFrame,
                           version_col: str,
                           pack_col: str,
                           attribut_col: str,
                           version_pack_fmt: str = "{version} + {pack}") -> pd.DataFrame:
    """
    Transforma tabela long (Version, Pack, Attribut por linha) em wide:
      Version | ATTR1 | ATTR2 | ...
    Valores são 0/1 inteiros.
    """
    df = df_long.copy()
    # Limpa strings
    df[version_col] = df[version_col].astype(str).str.strip()
    if pack_col in df.columns:
        df[pack_col] = df[pack_col].astype(str).replace("nan", "").replace("None", "").fillna("").str.strip()
    else:
        df[pack_col] = ""

    df[attribut_col] = df[attribut_col].astype(str).str.strip()

    # Monta chave VersionFull
    df["VersionFull"] = [build_version_id(v, p, version_pack_fmt) for v, p in zip(df[version_col], df[pack_col])]

    # flag de presença
    df["_PRES"] = 1

    # pivot: linhas = VersionFull, colunas = atributos
    df_wide = pd.pivot_table(
        df,
        index="VersionFull",
        columns=attribut_col,
        values="_PRES",
        aggfunc="max",
        fill_value=0
    ).reset_index().rename(columns={"VersionFull": "Version"})

    # garantir 0/1 inteiro
    attr_cols = [c for c in df_wide.columns if c != "Version"]
    df_wide[attr_cols] = df_wide[attr_cols].apply(lambda s: pd.to_numeric(s, errors="coerce").fillna(0).astype(int))

    return df_wide

# -----------------------------
# Parsing CCF combos
# -----------------------------
def parse_ccf_combo(combo: str) -> dict:
    """
    Recebe string do CCF como "[DDJ:04].[DEE:00]..." e retorna dict {KEY: VAL}.
    Tolerante a espaços/apóstrofos/pontos.
    """
    if combo is None:
        return {}
    s = str(combo).strip()
    # Normaliza aspas / apóstrofos comuns (em alguns arquivos, há acentos diferentes)
    s = s.replace("’", "'").replace("´", "'")
    # Remove espaços desnecessários e brackets externos
    s = s.replace(" ", "").strip("[]")
    # Particiona por . que separe atributos
    parts = [p for p in re.split(r"\]\.\[|\.|\]\[|\]\.", s) if p]
    res = {}
    for p in parts:
        if ":" in p:
            k, v = p.split(":", 1)
            res[k.strip().upper()] = v.strip().upper()
    return res

# -----------------------------
# Mapear colunas de atributo master para (KEY,VAL)
# -----------------------------
def key_val_from_code(code: str):
    """
    Interpreta nomes de colunas/atributos da master.
    Retorna (KEY, VAL) aproximado. Ex:
      "DEE:00" -> ("DEE","00")
      "DEE00"  -> ("DEE","00")
      "D0900"  -> ("D09","00") ou fallback ("D0900","")
    """
    if code is None:
        return ("", "")
    s = str(code).strip()
    if ":" in s:
        k, v = s.split(":", 1)
        return k.strip().upper(), v.strip().upper()
    # remove chars não alnum para tentar casar KEY+VAL
    s2 = re.sub(r'[^A-Za-z0-9]', '', s)
    # padrão: letras + dígitos finais
    m = re.match(r'^([A-Za-z]{1,})([0-9]{1,})$', s2)
    if m:
        return m.group(1).upper(), m.group(2).upper()
    # fallback: tudo maiúsculo como chave sem valor
    return s.upper(), ""

def values_equal(a, b) -> bool:
    """Comparação tolerante de valores: 04 == 4, '00' == '0', case-insensitive."""
    if a is None or b is None:
        return False
    a_s = str(a).strip().lstrip("0")
    b_s = str(b).strip().lstrip("0")
    return a_s.upper() == b_s.upper()

# -----------------------------
# Encontrar colunas candidatas numa família KEY
# -----------------------------
def build_key_to_cols(attr_cols):
    key_to_cols = defaultdict(list)
    for col in attr_cols:
        k, v = key_val_from_code(col)
        key_to_cols[k].append((v, col))
    return key_to_cols

def find_candidate_columns_for(k: str, v: str, attr_cols, key_to_cols):
    """
    Retorna lista de colnames na master que correspondem à key k e value v.
    Heurísticas:
      1) usa key_to_cols (parsing)
      2) tenta variantes diretas 'K:V', 'KV', 'K-V', 'K_V'
      3) compara sem pontuação
    """
    k = str(k).strip().upper()
    v = str(v).strip().upper()
    candidates = []

    # 1) do mapeamento parseado
    for val, col in key_to_cols.get(k, []):
        if values_equal(val, v):
            candidates.append(col)

    # 2) variantes literais
    variants = [f"{k}:{v}", f"{k}{v}", f"{k}-{v}", f"{k}_{v}"]
    for var in variants:
        for col in attr_cols:
            if col.upper() == var.upper() and col not in candidates:
                candidates.append(col)

    # 3) comparar sem pontuação (ex: col 'DEE00' vs target 'DEE00')
    target = (k + v).upper()
    for col in attr_cols:
        colnorm = re.sub(r'[^A-Za-z0-9]', '', col).upper()
        if colnorm == target and col not in candidates:
            candidates.append(col)

    return candidates

# -----------------------------
# Detectar coluna de combinação no CCF automaticamente
# -----------------------------
def find_combo_column(ccf_df: pd.DataFrame):
    keywords = ["cas d", "cas demploi", "combinaison", "combin", "epur", "emploi", "manquante"]
    for col in ccf_df.columns:
        norm = normalize_text(col)
        for k in keywords:
            if k in norm:
                return col
    # fallback: procura padrão [XX:YY] nas primeiras 200 linhas
    pattern = re.compile(r"\[[A-Za-z0-9]{2,}\s*[:：]\s*[A-Za-z0-9]{1,}\]")
    for col in ccf_df.columns:
        sample = ccf_df[col].astype(str).head(200).tolist()
        if any(pattern.search(s) for s in sample):
            return col
    return None

# -----------------------------
# Função principal: CLASSIFICAR
# -----------------------------
def classify_ccf(ccf_df: pd.DataFrame, df_wide: pd.DataFrame, combo_col: str = None, version_col_name: str = None):
    """
    Classifica o CCF contra a master (df_wide).
    - ccf_df: DataFrame do CCF (carregado)
    - df_wide: master wide (retorno de long_to_wide_with_pack)
    - combo_col: opcional, coluna do ccf_df que contém a combinação (se omitir, detecta automaticamente)
    - version_col_name: opcional, nome da coluna de versão em df_wide (por padrão usa primeira col)
    RETORNA DataFrame com colunas: Decoupage, NP, Estado, Combinação, Classificação, Versões_Impactadas, Unknown_AttrKeys, Qtd_Versões
    """
    # detecção da coluna combo
    if combo_col is None:
        combo_col = find_combo_column(ccf_df)
        if combo_col is None:
            raise RuntimeError("Não detectei a coluna de combinações no CCF. Passe combo_col explicitamente.")

    # coluna de versão na master
    if version_col_name is None:
        version_col = df_wide.columns[0]
    else:
        version_col = version_col_name

    # colunas de atributos na master (todas exceto a coluna de versão)
    attr_cols = [c for c in df_wide.columns if c != version_col]

    # normaliza presença: considera presença quando valor > 0
    presence_df = df_wide[attr_cols].apply(lambda s: pd.to_numeric(s, errors='coerce').fillna(0).astype(int) > 0)

    # mapeamento chave -> [(val,col)]
    key_to_cols = build_key_to_cols(attr_cols)

    results = []
    for _, row in ccf_df.iterrows():
        combo_raw = str(row.get(combo_col, "")).strip()
        combo_dict = parse_ccf_combo(combo_raw)  # {KEY:VAL}

        mask = pd.Series(True, index=df_wide.index)
        unknown_keys = []

        for k, v in combo_dict.items():
            cand_cols = find_candidate_columns_for(k, v, attr_cols, key_to_cols)
            if not cand_cols:
                unknown_keys.append(f"{k}:{v}")
                mask &= False
                continue
            # considera presente se ANY das candidate cols for True
            mask &= presence_df[cand_cols].any(axis=1)

        matched_versions = df_wide.loc[mask, version_col].astype(str).tolist()
        is_true = len(matched_versions) > 0

        # detectar 'estado' (TROU/DOUBLON)
        estado = (str(row.get("Etat PA") or row.get("Estado") or row.get("Type") or "")).strip()
        if not estado:
            tmp = " ".join(map(str, row.values)).upper()
            if "DOUBLON" in tmp: estado = "DOUBLON"
            elif "TROU" in tmp: estado = "TROU"
            else: estado = "TROU/DOUBLON"

        results.append({
            "Decoupage": row.get("DECOUPAGE PSA NP", row.get("DECOUPAGE", "")),
            "NP": row.get("Désignation NP", row.get("NP", "")),
            "Estado": estado,
            "Combinação": combo_raw,
            "Classificação": f"{estado} verdadeiro" if is_true else f"{estado} falso",
            "Versões_Impactadas": ";".join(matched_versions),
            "Unknown_AttrKeys": ";".join(unknown_keys) if unknown_keys else "",
            "Qtd_Versões": len(matched_versions)
        })

    return pd.DataFrame(results)

# -----------------------------
# Opcional: execução direta para teste
# -----------------------------
if __name__ == "__main__":
    # test minimal (ajuste caminhos locais se quiser rodar)
    import os
    print("ccf_core.py: execução de teste local")
    # Exemplo: carregar arquivos locais (descomente e ajuste)
    # df_master = pd.read_excel("Versoes_P21M_GENOME_clean.xlsx", dtype=str)
    # df_ccf = pd.read_excel("ccf_3.xlsx", dtype=str)
    # df_wide = long_to_wide_with_pack(df_master, "Version", "Pack", "Attribut")
    # out = classify_ccf(df_ccf, df_wide)
    # out.to_excel("resultado_classificacao_test.xlsx", index=False)